
Keywords:

Operators:

PP = \+\+
MM = --
ARR = ->
LSH = <<
RSH = >>
LEQ = <=
REQ = >=
EQ = ==
NEQ = !=
AND = &&
OR = \|\|
ADD_ASSIGN = +=
SUB_ASSIGN = -=
MUL_ASSIGN = *=
DIV_ASSIGN = /=
MOD_ASSIGN = %=
LSH_ASSIGN = <<=
RSH_ASSIGN = >>=
AND_ASSIGN = &=
XOR_ASSIGN = ^=
OR_ASSIGN = |=

Ids/literals:

IDENTIFIER = [a-zA-Z_][a-zA-Z0-9_]*
INTEGER = [+-]?([0-9]+|0[0-7]+|0[bB][0-1]+|0[xX][a-fA-F0-9]+)
REAL = [+-]?([0-9]+\\.[0-9]*|[0-9]*\\.[0-9]+)([+-]?[eE][0-9]+)?
CHARACTER = '\\?.'
STRING = "\w"

EBNF grammar:

decls = decl* ;

decl = func_decl | var_decl ;

func_decl = type_decl IDENTIFIER '(' params ')' '{' stmts '}' ;
var_decl = type_decl IDENTIFIER ('=' expr)? ';' ;

type_decl = base_type ;
base_type = CHAR | INT | FLOAT ;

params = (type_decl IDENTIFIER (',' type_decl IDENTIFIER)*)? ;

stmts = stmt* ;

stmt = decl
     | IF '(' expr ')' stmt
     | IF '(' expr ')' stmt ELSE stmt
     | WHILE '(' expr ')' stmt
     | RETURN expr ';'
     | expr ';'
     | '{' stmts '}' ;

expr = logical_or_expr
logical_or_expr = logical_and_expr (OR logical_and_expr)* ;
logical_and_expr = cmp_eq_expr (AND cmp_eq_expr)* ;
cmp_eq_expr = cmp_rel_expr ((EQ | NEQ) cmp_rel_expr)* ;
cmp_rel_expr = add_expr (('<' | LEQ | '>' | GEQ) add_expr)* ;
add_expr = mul_expr (('+' | '-') mul_expr)* ;
mul_expr = base_expr (('*' | '/') base_expr)* ;
base_expr = IDENTIFIER
          | IDENTIFIER '(' args ')'
          | INTEGER
          | REAL
          | CHARACTER
          | '(' expr ')' ;

args = (expr (',' expr)*)? ;

Grammar transform to LL(1):
decls_opt = decl decls_opt
          | --EPS-- ;
decl = type_spec IDENTIFIER decl_tail
decl_tail = '(' params_opt ')' '{' stmts '}'
          | '=' expr ';'
          | ';' ;
type_spec = CHAR | INT | FLOAT ;
params_opt = params | --EPS-- ;
params = type_spec IDENTIFIER params_tail ;
params_tail = ',' type_spec IDENTIFIER params_tail
            | --EPS-- ;
stmts = stmt stmts
      | --EPS-- ;
stmt = decl
     | expr ';'
     | IF '(' expr ')' stmt else_tail
     | WHILE '(' expr ')' stmt
     | RETURN expr ';'
     | '{' stmts '}' ;
else_tail = ELSE stmt
          | --EPS-- ;
expr = logical_or_expr
logical_or_expr = logical_and_expr logical_or_expr_tail
logical_or_expr_tail = OR logical_or_expr
                     | --EPS-- ;
logical_and_expr = cmp_eq_expr logical_and_expr_tail
logical_and_expr_tail = AND logical_and_expr
                      | --EPS-- ;
cmp_eq_expr = cmp_rel_expr cmp_eq_expr_tail
cmp_eq_expr_tail = EQ cmp_eq_expr
                 | NEQ cmp_eq_expr
                 | --EPS-- ;
cmp_rel_expr = add_expr cmp_rel_expr_tail
cmp_rel_expr_tail = '<' cmp_rel_expr
                  | LEQ cmp_rel_expr
                  | '>' cmp_rel_expr
                  | GEQ cmp_rel_expr
                  | --EPS-- ;
add_expr = mul_expr add_expr_tail
add_expr_tail = '+' add_expr
              | '-' add_expr
              | --EPS-- ;
mul_expr = base_expr mul_expr_tail
mul_expr_tail = '*' mul_expr
              | '/' mul_expr
              | --EPS-- ;
base_expr = IDENTIFIER base_id_expr_tail
      | INTEGER
      | REAL
      | CHARACTER
      | '(' expr0 ')' ;
base_id_expr_tail = --EPS-- | '(' args_opt ')' ;
args_opt = args | --EPS-- ;
args = expr0 ',' args
     | expr0 ;
